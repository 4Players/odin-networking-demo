# Odin Networking

Odin is a client/server voice and networking solutions based on latest technology and deep engine integration. Build a complete multiplayer
experience with 3D audio, avatar synchronisation for hundreds of users in a couple of hours!

Odin consists of various building blocks that work together to make your development experience as simple as possible. You can drop various
building blocks that we provide and built your own custom implementation.

## Odin Core SDK

This is the core library built in Rust and made available as a standard C library. All our SDKs for the various platforms are built on top
of this core SDK. Learn more about the core library [here](https://www.4players.io/odin/sdk/c/).

## Odin C# SDK

The C# SDK is a wrapper around the Core SDK and provides a C# based interface. It's the foundation of the Unity SDK.

## Odin Unity SDK

The Unity SDK offers a deep game engine integration with easy to use components and inspector scripts that allow you to create access
keys and other settings directly in the Unity editor. This SDK provides the main building block for your custom voice and networking 
solution by exposing events that you can connect to if users connect to the server and provides ready to go voice support. Learn more
about the Unity SDK in our [developer documentation](https://www.4players.io/odin/sdk/unity/manual/).

## Odin Audio

We leverage Unitys audio pipeline for capture and playback. This is the reason why the integration is so simple. There are no functions
that you need to call to send and receive audio data or adjusting volume based on the position to simulate 3D audio. Instead, we deeply
integrated Odin into Unity. You will use Unitys `AudioMixer` for sound effects, and the standard `AudioListener` and `AudioSource`. The
only difference is, that it's not a static media asset but that its dynamic content generated by your users in real-time (i.e. one
player talking).

But, Unity has its weaknesses. Although Unity provides 3D audio support, it does not have any support for audio occlusion. Imagine
two players standing 1 meter away. If one says something, the other will clearly here him. But volume will be different if the player
is talking in the opposite direction. In the second case, a concrete wall is between the players. The players volume will be very low
or cannot be heard at all depending on the material and thickness of the wall. Unity only handles distance, but not direction or 
objects in between.

This is where Odin Audio comes into play. We provide easy to use scripts that are handle direction and occlusion. For example, in your
scene you just add a component to the wall and select an audio effect asset that mimics the audio damping of that material. We provide
audio effects of standard materials like glass, concrete, bricks and many more, but you can also create your own.

## Odin Networking

Odin Networking is built on top of the Odin Unity SDK and provides easy to use methods to built virtual experiences with ease that allow
you to connect users with virtual characters and real-time 3D voice. A 3D virtual conferencing application can be built in no time,
as Odin Networking provides components that automatically synchronize position, animation of all characters over the Odin servers.

Users can spawn objects in the world and can interact with the provided world in real-time. Odin Networking also integrates Odin Audio
so your virtual world will automatically integrate audio occlusion (users cannot here each other if walls are in between) and even
direction.

**One important aspect**: While Odin Networking is a powerful and easy to use system, it's mainly targeted for real-world like applications
for the metaverse, board games, virtual conferences and conventions. If you want to build a fast competitive first person shooter or 
real-time physics racing game Odin Network is not the best solution. Choose other solutions like Mirror Networking or Photon for that use 
case. You should still use Odin for voice support and we have many [guides](https://www.4players.io/odin/guides/unity/) on how to 
integrate Odin into Mirror or Photon.

# Getting Started

In Odin, every peer can have arbitrary user data that is kept in sync automatically with all other peers connected to the same room.
Odin also supports room data, which is arbitrary data stored for the room and also kept in sync with all peers. Last but not least,
Odin provides support for messages which can be sent to all or selected peers.

Odin Networking makes use of these structures to provide a powerful and easy to use networking solution. Odin Networking automatically
creates a flexible data structure that contains the position and animation of the character. It also contains so called sync vars that
are properties that are automatically synced with the network. I.e. if players have different color. Next, players can spawn objects
to the world. For example a player can drop an item and another player can pick it up. All this data is compiled into the peers
user data and updated 10 times per second.

The system automatically and dynamically defines one peer to be the host. This host handles world objects, i.e. objects that don't have
an owner and are part of the world. Think of a stack of cubes that are part of the world and can be manipulated by the users.

It's best to have one instance to have authority over the world (in other use cases a dedicated server does that). As Odin does not
have a special dedicated gameserver but generic real-time data processing units, one peer in the network becomes the host. You as
a developer don't have to do anything here, as Odin Networking handles all that internally for you. 

## Building a player prefab

First, you need to create a player object. In most cases this is human character with an Animator attached. Based on the speed or
current input the Animator plays idle or walking animations and the root of the character moves around in the world. To get started
you can also just use a capsule and attach a character controller to it.

Next, you need to create a new script derived from `OdinPlayer` and attach it to the characters root game object. Make sure to only
handle any input if it's the local player, i.e. like this:

```C#
void Update()
{
   // Do nothing if this is a remote peer (position is updated from the network)
   if (!IsLocalPlayer) return;
   
   // Handle input and change transform and/or animation parameters of the character
}

void OnStartLocalClient()
{
    // Activate input controller and attach a camera
    Camera.main.followTarget = this.transform;
}
```

`OdinPlayer` has two two important requirements: `Odin Ears` and `Odin Mouth`. If you want to have real-time voice support, you need to
drag the provided `OdinEars` and `OdinMouth` prefabs into your character prefab and position them where the avatars ears and mouth
are located. These objects handle voice output and the listener of the player object.

Next, make sure that `Sync Transform` is enabled and if your character has animation also make sure that `Sync Animation` is enabled, too. 

Last but not least, you should configure the Player prefab so that it does not handle any input and does not include any camera as
we use the same player prefab for remote players and the local player. You can adjust all of this behaviour by overriding a few functions.

`OnStartLocalClient` is only called on the local player object, so that is the place to activate the input controller and to attach a camera
to the player object.

## Adding Odin Manager

Drag & Drop the Odin Manager prefab from the Odin SDK into your scene. Make these adjustments in the inspector:

- Enter your Access Key in `Client Authentication` or let Odin automatically generate a key for you.
- In the `Odin Handler` script make sure that `Manual positional audio` is selected as `OdinNetworkManager` will handle audio and not the
  `Odin Handler` script.
- Make sure that `Autostart Microphone` is enabled in the `Mic and Room Settings`.

## Adding Network Manager

Now you need to create a game object and add the `OdinNetworkManager` script to it. You can set the name of the room and various other
settings. 

Make sure that `Auto Connect` is enabled for this example and that you enter an name into `Room Name` (can be "World"). 

Drag and Drop the player prefab to the `Player Prefab` inspector setting. `OdinNetworkManager` will generate an instance of this
prefab for every player that connects to same room.

In the `Player Spawn Method` chose `Round Robbin` instead of `Random`. This makes debugging a bit easier as spawn points will be used
one after the other instead of random that can lead to collisions or overlapping players.

## Adding Spawn points

We need to define the places where new players get spawned. Create a game object and attach the `OdinNetworkSpawnPosition` script to it. 
Position it somewhere in your scene. Voila, we have a first spawn point. Duplicate the object and place them also in the scene.

## Adding Odin World

Last but not least, create another script and derive it from `OdinWorld`. This script will handle the worlds settings and properties
and will automatically be kept in sync with all players. For example you could store if a light in a room is enabled or not. Then, if
someone toggles the light, changes will be synced with the network. Create another game object and add your world script to it.

## Press Play

If you press play, `OdinNetworkManager` will automatically connect to the room you provided in the inspector and will create an instance
of the player prefab. You should be able to control the player and it feels much the same as if you simply build a single player game, right.

Now, Build your application and launch that, too. Make sure to have the Play button pressed in the Editor. Once the application launches
it will also connect the same room, receive a message that a player already exists and will spawn two player objects at different spawn points.

You should now see two players that automatically sync position and animation.

# Add Player Customization

Although this is great, it's a bit boring, as all player objects look the same. You can use Sync Vars to define player variables that
will automatically kept in sync. 

## Adding a sync var

Add this member variable to your player script. It will be an integer that is kept in sync automatically with the network. So, if you change
the value in your player object as you would in a single player app, Odin Networking automatically updates that value for each player in the
network. In the `hook` you can provide a callback function that will be called once the value changes. 

There is no need to send commands or rpc calls to do all that. Odin Networking does that all automatically for you. Just change values as you
are used to and Odin Networking will make sure in the background that everything is kept in sync.

```C#
public class MyPlayer : OdinPlayer
{
    [OdinSyncVar(hook=nameof(OnBodyColorChanged))]
    public int BodyColor = 0;
  
    void Update()
    {
      if (!IsLocalPlayer) return;
      
      // Cycle through the body colors
      if (Input.GetKeyUp("space"))
      {
        BodyColor++;
        if (BodyColor >=3) {
          BodyColor = 0;
        }
      }
    }
    
    //...
}
```

Just syncing an integer value over the network does not change the color. Therefore, we need to do something. This is just an example.
You will need to adjust the code so that it fits your characters structure but in most cases this code should change the material
color of your character, or at least of one part of it.

```C#
public class MyPlayer : OdinPlayer
{
    //...
    
    public void OnBodyColorChanged(int oldColor, int newColor)
    {
        Debug.Log("BODY COLOR CHANGED");

        SkinnedMeshRenderer meshRenderer = GetComponentInChildren<SkinnedMeshRenderer>();
        if (meshRenderer == null) return;

        if (newColor == 0)
        {
            meshRenderer.materials[0].color = Color.white;
        } 
        else if (newColor == 1)
        {
            meshRenderer.materials[0].color = Color.red;
        }
        else if (newColor == 2)
        {
            meshRenderer.materials[0].color = Color.blue;
        }
    }
    
    //...
}
```

The hook function always has this structure:
`(oldColor, newColor) => void`

Let's test it: Build your application and run it. Press Play in the Unity editor. You should see two player objects in the scene.
Press Space in the application and the body color will change in both screens. Do the same in the Editor and it will also change
in the application.

That's it. It's that easy to extend your players functionality. Instead of changing material colors you could also spawn different
clothing objects like hats or change skins, whatever makes sense for you.

In a nutshell, we just build a data structure with sync vars that describe the state. And we respond to state changes by adjusting
the scene. As the state is synced over the network, the same changes will be applied at all clients at (roughly) the same time and
everyone sees the same things.

